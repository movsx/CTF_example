# -*- coding: utf-8 -*-
import sys
### Merkle–Hellman knapsack cryptosystem
# условие
"""
def generate_public_key(private_key):
	n = 199285318978668966527551342512997250816637709274749259983292077699440369
	t = 32416190071
	return list(map(lambda x: (t * x) % n, private_key))

def crypt(open_text, public_key):
	bts = []
	[bts.extend([int(b) for b in '00000000'[len(bin(ord(c))[2:]):] + bin(ord(c))[2:]]) for c in open_text]
	return [sum(map(lambda x: x[0] * x[1] ,zip(blk, public_key))) for blk in [bts[i * 128:(i+1) * 128] for i in range(len(open_text) // 16)]]

public_key = [1050809378719198985041, 2101618757438397970082, 6304856272315193910246, 18914568816945581730738, 56743706450836745192214, 170231119352510235576642, 510693358057530706729926, 1532080074172592120189778, 4596240222517776360569334, 13788720667553329081708002, 41366162002659987245124006, 124098486007979961735372018, 372295458023939885206116054, 1116886374071819655618348162, 3350659122215458966855044486, 10051977366646376900565133458, 30155932099939130701695400374, 90467796299817392105086201122, 271403388899452176315258603366, 814210166698356528945775810098, 2442630500095069586837327430294, 7327891500285208760511982290882, 21983674500855626281535946872646, 65951023502566878844607840617938, 197853070507700636533823521853814, 593559211523101909601470565561442, 1780677634569305728804411696684326, 5342032903707917186413235090052978, 16026098711123751559239705270158934, 48078296133371254677719115810476802, 144234888400113764033157347431430406, 432704665200341292099472042294291218, 1298113995601023876298416126882873654, 3894341986803071628895248380648620962, 11683025960409214886685745141945862886, 35049077881227644660057235425837588658, 105147233643682933980171706277512765974, 315441700931048801940515118832538297922, 946325102793146405821545356497614893766, 2838975308379439217464636069492844681298, 8516925925138317652393908208478534043894, 25550777775414952957181724625435602131682, 76652333326244858871545173876306806395046, 229956999978734576614635521628920419185138, 689870999936203729843906564886761257555414, 2069612999808611189531719694660283772666242, 6208838999425833568595159083980851317998726, 18626516998277500705785477251942553953996178, 55879550994832502117356431755827661861988534, 167638652984497506352069295267482985585965602, 502915958953492519056207885802448956757896806, 1508747876860477557168623657407346870273690418, 4526243630581432671505870972222040610821071254, 13578730891744298014517612916666121832463213762, 40736192675232894043552838749998365497389641286, 122208578025698682130658516249995096492168923858, 366625734077096046391975548749985289476506771574, 1099877202231288139175926646249955868429520314722, 3299631606693864417527779938749867605288560944166, 9898894820081593252583339816249602815865682832498, 29696684460244779757750019448748808447597048497494, 89090053380734339273250058346246425342791145492482, 267270160142203017819750175038739276028373436477446, 801810480426609053459250525116217828085120309432338, 2405431441279827160377751575348653484255360928297014, 7216294323839481481133254726045960452766082784891042, 21648882971518444443399764178137881358298248354673126, 64946648914555333330199292534413644074894745064019378, 194839946743665999990597877603240932224684235192058134, 584519840230997999971793632809722796674052705576174402, 1753559520692993999915380898429168390022158116728523206, 5260678562078981999746142695287505170066474350185569618, 15782035686236945999238428085862515510199423050556708854, 47346107058710837997715284257587546530598269151670126562, 142038321176132513993145852772762639591794807455010379686, 426114963528397541979437558318287918775384422365031139058, 1278344890585192625938312674954863756326153267095093417174, 3835034671755577877814938024864591268978459801285280251522, 11505104015266733633444814074593773806935379403855840754566, 34515312045800200900334442223781321420806138211567522263698, 103545936137400602701003326671343964262418414634702566791094, 310637808412201808103009980014031892787255243904107700373282, 931913425236605424309029940042095678361765731712323101119846, 2795740275709816272927089820126287035085297195136969303359538, 8387220827129448818781269460378861105255891585410907910078614, 25161662481388346456343808381136583315767674756232723730235842, 75484987444165039369031425143409749947303024268698171190707526, 226454962332495118107094275430229249841909072806094513572122578, 679364886997485354321282826290687749525727218418283540716367734, 2038094660992456062963848478872063248577181655254850622149103202, 6114283982977368188891545436616189745731544965764551866447309606, 18342851948932104566674636309848569237194634897293655599341928818, 55028555846796313700023908929545707711583904691880966798025786454, 165085667540388941100071726788637123134751714075642900394077359362, 495257002621166823300215180365911369404255142226928701182232078086, 1485771007863500469900645541097734108212765426680786103546696234258, 4457313023590501409701936623293202324638296280042358310640088702774, 13371939070771504229105809869879606973914888840127074931920266108322, 40115817212314512687317429609638820921744666520381224795760798324966, 120347451636943538061952288828916462765233999561143674387282394974898, 361042354910830614185856866486749388295701998683431023161847184924694, 1083127064732491842557570599460248164887105996050293069485541554774082, 3249381194197475527672711798380744494661317988150879208456624664322246, 9748143582592426583018135395142233483983953964452637625369873992966738, 29244430747777279749054406185426700451951861893357912876109621978900214, 87733292243331839247163218556280101355855585680073738628328865936700642, 63914557751326551213938313155843053250929047765471955901694520110661557, 191743673253979653641814939467529159752787143296415867705083560331984671, 176660381804601027870342133376592977625086011339749083148666525597073275, 131410507456465150555923715103784431241982615469748729479415421392339087, 194946203390726485140219802798356042909310137134496928454954186477576892, 186267972214841522365556723369073627094654992853992265398278404033849938, 160233278687186634041567485081226379650689560012478276228251056702669076, 82129198104221969069599770217684637318793261487936308718169014709126490, 47102275333996940681247968140056661139742075189059666171214966427939101, 141306826001990822043743904420169983419226225567178998513644899283817303, 25349840048634533076129028234515448624403258152038475574350542452571171, 76049520145903599228387084703546345873209774456115426723051627357713513, 28863241459041831157609911597641786802991614093597020185862804373700170, 86589724377125493472829734792925360408974842280791060557588413121100510, 60483854152707513890937861865778830410286817567623921689473161663861161, 181451562458122541672813585597336491230860452702871765068419484991583483, 145784049417029691963338071766014972059305939559116775238674299575869711, 38781510293751142834911530272050414544642400127851805749438743328728395, 116344530881253428504734590816151243633927200383555417248316229986185185, 149748273665091318986652429935456480085143891875916991761656612259115186, 50674183037936023904854604780374938622156257078252455318385681378464820, 152022549113808071714563814341124815866468771234757365955157044135394460]
cipher_text =
	[
		1387977778999926469357780220487630125151962348185941993910077394771302677,
		1192236960845781949613172279312582839292898077268409678421304772227241438,
		1295152741157953792099179799985052248167548374589648818528421499250916999,
		828724787424187908000366458781164595076558885463707900320215679908512646,
		1179926879709109047038661681316962368287877340885819899201698611790531134,
		965171312356484716595815857561729919489896088681139239093293829323154838,
		1099367377207651843612375443021502714028353049437532392256489525051038347,
		1374891605015623267623322424512489936836885983493815443812918444687247914,
		1152880248428103510879661300981452627677389745079857275081612568623556291,
		962409003220820525413536841942678826309419979028794415812582008820263317
	]
"""
# решение 1
def Merkle():
    n = 199285318978668966527551342512997250816637709274749259983292077699440369
    t = 32416190071
    public_key = [ 1050809378719198985041, 2101618757438397970082, 6304856272315193910246, 18914568816945581730738, 56743706450836745192214, 170231119352510235576642, 510693358057530706729926, 1532080074172592120189778, 4596240222517776360569334, 13788720667553329081708002, 41366162002659987245124006, 124098486007979961735372018, 372295458023939885206116054, 1116886374071819655618348162, 3350659122215458966855044486, 10051977366646376900565133458, 30155932099939130701695400374, 90467796299817392105086201122, 271403388899452176315258603366, 814210166698356528945775810098, 2442630500095069586837327430294, 7327891500285208760511982290882, 21983674500855626281535946872646, 65951023502566878844607840617938, 197853070507700636533823521853814, 593559211523101909601470565561442, 1780677634569305728804411696684326, 5342032903707917186413235090052978, 16026098711123751559239705270158934, 48078296133371254677719115810476802, 144234888400113764033157347431430406, 432704665200341292099472042294291218, 1298113995601023876298416126882873654, 3894341986803071628895248380648620962, 11683025960409214886685745141945862886, 35049077881227644660057235425837588658, 105147233643682933980171706277512765974, 315441700931048801940515118832538297922, 946325102793146405821545356497614893766, 2838975308379439217464636069492844681298, 8516925925138317652393908208478534043894, 25550777775414952957181724625435602131682, 76652333326244858871545173876306806395046, 229956999978734576614635521628920419185138, 689870999936203729843906564886761257555414, 2069612999808611189531719694660283772666242, 6208838999425833568595159083980851317998726, 18626516998277500705785477251942553953996178, 55879550994832502117356431755827661861988534, 167638652984497506352069295267482985585965602, 502915958953492519056207885802448956757896806, 1508747876860477557168623657407346870273690418, 4526243630581432671505870972222040610821071254, 13578730891744298014517612916666121832463213762, 40736192675232894043552838749998365497389641286, 122208578025698682130658516249995096492168923858, 366625734077096046391975548749985289476506771574, 1099877202231288139175926646249955868429520314722, 3299631606693864417527779938749867605288560944166, 9898894820081593252583339816249602815865682832498, 29696684460244779757750019448748808447597048497494, 89090053380734339273250058346246425342791145492482, 267270160142203017819750175038739276028373436477446, 801810480426609053459250525116217828085120309432338, 2405431441279827160377751575348653484255360928297014, 7216294323839481481133254726045960452766082784891042, 21648882971518444443399764178137881358298248354673126, 64946648914555333330199292534413644074894745064019378, 194839946743665999990597877603240932224684235192058134, 584519840230997999971793632809722796674052705576174402, 1753559520692993999915380898429168390022158116728523206, 5260678562078981999746142695287505170066474350185569618, 15782035686236945999238428085862515510199423050556708854, 47346107058710837997715284257587546530598269151670126562, 142038321176132513993145852772762639591794807455010379686, 426114963528397541979437558318287918775384422365031139058, 1278344890585192625938312674954863756326153267095093417174, 3835034671755577877814938024864591268978459801285280251522, 11505104015266733633444814074593773806935379403855840754566, 34515312045800200900334442223781321420806138211567522263698, 103545936137400602701003326671343964262418414634702566791094, 310637808412201808103009980014031892787255243904107700373282, 931913425236605424309029940042095678361765731712323101119846, 2795740275709816272927089820126287035085297195136969303359538, 8387220827129448818781269460378861105255891585410907910078614, 25161662481388346456343808381136583315767674756232723730235842, 75484987444165039369031425143409749947303024268698171190707526, 226454962332495118107094275430229249841909072806094513572122578, 679364886997485354321282826290687749525727218418283540716367734, 2038094660992456062963848478872063248577181655254850622149103202, 6114283982977368188891545436616189745731544965764551866447309606, 18342851948932104566674636309848569237194634897293655599341928818, 55028555846796313700023908929545707711583904691880966798025786454, 165085667540388941100071726788637123134751714075642900394077359362, 495257002621166823300215180365911369404255142226928701182232078086, 1485771007863500469900645541097734108212765426680786103546696234258, 4457313023590501409701936623293202324638296280042358310640088702774, 13371939070771504229105809869879606973914888840127074931920266108322, 40115817212314512687317429609638820921744666520381224795760798324966, 120347451636943538061952288828916462765233999561143674387282394974898, 361042354910830614185856866486749388295701998683431023161847184924694, 1083127064732491842557570599460248164887105996050293069485541554774082, 3249381194197475527672711798380744494661317988150879208456624664322246, 9748143582592426583018135395142233483983953964452637625369873992966738, 29244430747777279749054406185426700451951861893357912876109621978900214, 87733292243331839247163218556280101355855585680073738628328865936700642, 63914557751326551213938313155843053250929047765471955901694520110661557, 191743673253979653641814939467529159752787143296415867705083560331984671, 176660381804601027870342133376592977625086011339749083148666525597073275, 131410507456465150555923715103784431241982615469748729479415421392339087, 194946203390726485140219802798356042909310137134496928454954186477576892, 186267972214841522365556723369073627094654992853992265398278404033849938, 160233278687186634041567485081226379650689560012478276228251056702669076, 82129198104221969069599770217684637318793261487936308718169014709126490, 47102275333996940681247968140056661139742075189059666171214966427939101, 141306826001990822043743904420169983419226225567178998513644899283817303, 25349840048634533076129028234515448624403258152038475574350542452571171, 76049520145903599228387084703546345873209774456115426723051627357713513, 28863241459041831157609911597641786802991614093597020185862804373700170, 86589724377125493472829734792925360408974842280791060557588413121100510, 60483854152707513890937861865778830410286817567623921689473161663861161, 181451562458122541672813585597336491230860452702871765068419484991583483, 145784049417029691963338071766014972059305939559116775238674299575869711, 38781510293751142834911530272050414544642400127851805749438743328728395, 116344530881253428504734590816151243633927200383555417248316229986185185, 149748273665091318986652429935456480085143891875916991761656612259115186, 50674183037936023904854604780374938622156257078252455318385681378464820, 152022549113808071714563814341124815866468771234757365955157044135394460 ]
    cipher_text = [ 1387977778999926469357780220487630125151962348185941993910077394771302677, 1192236960845781949613172279312582839292898077268409678421304772227241438, 1295152741157953792099179799985052248167548374589648818528421499250916999, 828724787424187908000366458781164595076558885463707900320215679908512646, 1179926879709109047038661681316962368287877340885819899201698611790531134, 965171312356484716595815857561729919489896088681139239093293829323154838, 1099367377207651843612375443021502714028353049437532392256489525051038347, 1374891605015623267623322424512489936836885983493815443812918444687247914, 1152880248428103510879661300981452627677389745079857275081612568623556291, 962409003220820525413536841942678826309419979028794415812582008820263317 ]
    private_key = [ t ] + [ t * 2 * 3 ** i for i in xrange( 0, 127 ) ]
    t2inv = 113733348753781020783170490400630827179237386517084745662682984487937812

    def dec( block ):
        r = ''
        ohlol = t2inv * block % n
        if ohlol % 2 == 1:
            r += '1'
            ohlol -= 1
        ohlol /= 2
        for i in xrange( 1, 128 ):
            r += '%s' % (ohlol % 3 ** i / 3 ** (i - 1))
        return hex( int( r, 2 ) )[ 2: ].rstrip( 'L' ).decode( 'hex' )

    for c in cipher_text:
        try:
            sys.stdout.write( dec( c ) )
        except:
            print 'FAIL'

# решение 2
"""
This is what we got when analysing the public_key list:

    sage: factor(1050809378719198985041)
    32416190071^2
    sage: factor(2101618757438397970082)
    2 * 32416190071^2
    sage: factor(6304856272315193910246)
    2 * 3 * 32416190071^2
    sage: factor(18914568816945581730738)
    2 * 3^2 * 32416190071^2
    sage: factor(56743706450836745192214)
    2 * 3^3 * 32416190071^2
    sage: factor(170231119352510235576642)
    2 * 3^4 * 32416190071^2

Looks like the private_key is generated based on the given 't' value. This is how we generated the private_key list

    private_key = [t]
    for i in range(0,127):
        private_key.append(2 * 3**i * t)

The generated private keys can be verified using the given generate_public_key() function. We got a match. Then we wrote the routine for inverse knapsack sum to get the flag. Here is the final code:
"""
def Merkle2():
    n = 199285318978668966527551342512997250816637709274749259983292077699440369
    t = 32416190071
    t_inv = 3607086840002694423309872675805192458275553329397325526691156370525160 #sage: inverse_mod(t,n)

    private_key = [t]
    for i in range(0,127):
        private_key.append(2 * 3**i * t)

    cipher_text = [
      1387977778999926469357780220487630125151962348185941993910077394771302677,
      1192236960845781949613172279312582839292898077268409678421304772227241438,
      1295152741157953792099179799985052248167548374589648818528421499250916999,
      828724787424187908000366458781164595076558885463707900320215679908512646,
      1179926879709109047038661681316962368287877340885819899201698611790531134,
      965171312356484716595815857561729919489896088681139239093293829323154838,
      1099367377207651843612375443021502714028353049437532392256489525051038347,
      1374891605015623267623322424512489936836885983493815443812918444687247914,
      1152880248428103510879661300981452627677389745079857275081612568623556291,
      962409003220820525413536841942678826309419979028794415812582008820263317
           ]

    def decrypt(cipher, private_key):   # inverse knapsack

        bts = ['0']*128                 # generate bit string
        for i in range(len(private_key) - 1, -1, -1):
            if cipher >= private_key[i]:
                bts[i] = '1'
                cipher = cipher - private_key[i]

        for j in range(0,128,8):        # generate chars out of every 8-bits
            sys.stdout.write(chr(int(''.join(bts[j:j+8]),2)))

    for c in cipher_text:               # iterate through 10 blocks
        decrypt((c * t_inv) % n,private_key)
    print ''


### Пример взлома RSA методом факторизации Ферма на основе того, что в задаче p и q расположены близко друг к другу
# Ссылка на метод факторизации Ферма http://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D1%84%D0%B0%D0%BA%D1%82%D0%BE%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8_%D0%A4%D0%B5%D1%80%D0%BC%D0%B0
### Условие
# n = 52663327194823108047941861363554667296911056447871 88785127198792390818389767437741043884042697813417 40858276714053716810874389770623503703996736687974 70776186113807376857893834326388369431932515506157 59902933749676883316817097953054649047764645797986 77703632934375663507898357576891627341435121532539 03202593
# e = 10662335266334707061416010175090707752184800780484 87199510272395686606199019585683070878871806968902 65830636660853997681894517472390188901902543758517 09269
# cipher-text = 10462822375277205946365199641597262713749993739943 57909091506537398272791306618098458481620423392938 70744463265888874276961969971096108086452105647668 82647584743088857818448828460464362997716024535291 28094029803725929915632320170106381959701908835246 76285475884921692502194212799981792187650488093680 64725175
### Решение
# Since python's float->int casting is inaccurate, I used SAGE.
# An actual s=(p-q)/2 value was obtained from the very first iteration:
### Код:
# sage: r=ceil(sqrt(n))
# sage: t=r+0 #first iteration
# sage: s=sqrt(t**2-n)
# sage: s #should be integer
# 1754844
# sage: p=t-s
# sage: q=t+s
#sage: phi=(p-1)*(q-1)
# sage: d=pow(e,-1,phi)
# sage: pow(c,d,n)
# 22424170465
### The flag is 22424170465

### Пример взлома простых алгоритмов перебором
# Условие
# cipher-text     168 232 100 162 135 179 112 100 173 206 106 123 106 195 179 157 123 173
# Алгоритм шифрования
"""
    for ($i = 0; $i<strlen($str); $i++)
    $dec_array[] = ord($str{$i});
    $ar = $dec_array;
    $max = max($ar);

    $key = rand(10,$max);
    $key = 101*$key;

    for($i=0;$i<strlen($str);$i++){
    $x = $ar[$i];
    $am = ($key+$x)/2;
    $gm = sqrt($key*$x);
    $enc = $am + $gm;
    $encrypt = floor($enc)%255;
    echo $encrypt.' ';
    } """
### Решение (флаг: myalgocantbebroken)
import math
def sample_bruteenc():
    cipher = (168, 232, 100 ,162, 135, 179, 112, 100, 173, 206, 106, 123, 106, 195, 179, 157, 123, 173)
    for key in range (10,128):
        plain = []
        key_new = key * 101
        for i in range (0, len(cipher)):
            for p in range(32,128):
                x = p
                am = float(key_new+x)/2
                gm = math.sqrt(key_new*x)
                enc = am + gm
                encrypt = int(enc)%255
                if(encrypt == cipher[i]):
                    plain.append(p) #array_push($plain,$p);
        if(len(plain) == len(cipher)):
            print ''.join( [chr(t) for t in plain] )

### Еще один пример перебора, но уже с использованием RSA
# Условие
# Алгоритм
"""
    cmd = raw_input('[0] Get auth key\n[1] Login\n[2] Exit\n').strip()
    if cmd == '0':
        login = raw_input('Enter your login:\n').strip()
        if re.search('[^a-zA-Z0-9]', login):
            print 'Bad login'
            continue
        if login == self.admin:
            print 'Not for admins!'
        elif len(login) < self.max_login_len:
            m = self.str_to_hash(login)
            auth_key = self.binpow(m, self.d, self.n)
            print 'Your auth key:\n%s' % base64.b64encode(str(auth_key))
        else:
            print 'Error'
    elif cmd == '1':
        login = raw_input('Login:\n').strip()
        auth_key = raw_input('Auth key:\n').strip()
        try:
            auth_key = int(base64.b64decode(auth_key))
        except:
            print 'Error'
            continue
        c = self.str_to_hash(login)
        if c == self.binpow(auth_key, self.e, self.n):
            if login == self.admin:
                flag = open('flag.txt','r').readline().strip()
                print 'You win!\nFlag is: %s' % flag
            else:
                print 'Welcome, %s! You are not admin' % login
        else:
            print 'Wrong auth key!'
    elif cmd == '2':
        sys.exit(0)
"""
### Мысли
# Summary of service:
# [*] The service calculates the hash value of login name
# [*] Then signs on the hash value as hash(m)^d mod n. This is sent back as authorization key
#[*] The service doesn't sign when the login name is 'admin357'
# [*] We will get flag if we could forge the signature of 'admin357' and validate ourself as admin
#
# The public exponent e and modulo n value are given. Private exponent d is unknown.
#
# e = 65537
# n = 24007134668077839318704239757833363695524302813772795891485519226984107072647247568832064425929097558895623559893945502194926707312564453230806425423424997149843823227221596369795583261387779649714834167992749218150200223683296423069590080742550774828141844004559612066990484264910946488068587829100994639319674561758961812687482393281457478086918858906261630888892035335571465704005412337006332665433676386472229329420439767309647448615375682557274786037161968945400623209502352428011196477777002370787813952767888262642821196216644015950350716009261032012403125915949137853338061422774091806367454086620172463286011

# After some googling I came across this paper How Not to Design RSA Signature Schemes. It gave good summary of attacks on RSA system.
# Page 8 describes The Desmedt and Odlyzko Attack against RSA Signatures that use Hash Function. This is what the attack says

# [*] It applies to signatures when messages to sign are relatively small
# [*] Factor the message we wish to forge into small primes
# [*] Obtain signatures for these small primes [ Sig(m1) and Sig(m2) ]
# [*] Produce the signature by multiplying the factors signature [ Sig('admin357') = Sig(m1)) * Sig(m2) mod n ]

# This method looked much feasible and relevant for this particular challenge. We do the above steps to get the flag.
# Using the hash function defined in source code, we find the hash value of 'admin357' as 240021000768277

# sage: factor(240021000768277)
# 2879449 * 83356573

# Now we should find the two messages whose hash values are 2879449 and 83356573. For this, write a bruteforcer
### Брутфорсер с потокамм

from multiprocessing import Process
import string

charset = map(chr,range(ord('a'),ord('z')+1)+range(ord('A'),ord('Z')+1)+range(ord('0'),ord('9')+1)) # устанавливаем множество символов
p = len(charset)+1
sec_option = string.ascii_letters + string.digits
threads = 10
size = len(sec_option)/threads

def find_login(start, end):
    for i in sec_option[start:end]:
        for j in sec_option:
            for k in sec_option:
                for l in sec_option:
                    for m in sec_option:
                        s = i + j + k + l + m
                        res = 0
                        p_pow = 1
                        for ch in s:
                            res = res + (charset.index(ch) + 1) * p_pow
                            p_pow = p_pow * p
                        if res == 83356573: # печатаем резудьтат для m4vre
                            print "hash ",s,"= 83356573"
                        if res == 2879449: # печатаем резудьтат для HDFk
                            print "hash ",s,"= 2879449"

def sample_bruteThreadin():
    for i in range(threads):
        if i == threads - 1:
            pro = Process(target=find_login, args=(end, len(sec_option)))
        else:
            start = i*size
            end = (i+1)*size
            pro = Process(target=find_login, args=(start, end))
        pro.start()

# hash(HDFk)  == 2879449
# hash(m4vre) == 83356573

# Now find the signatures of these two messages:

# Enter your login:
# HDFk
# Your auth key:
# MjAyMTc3NTc0ODE4MDk3NjI4NTgxNjkyNjU1NTkyNDU2OTczMzc4MTkyMzYzMjQ0MTI2MzQ0MTY2MTE3MDc4NTU1ODI1MjU2OTQyNTg5ODYzNjE3MjQxMTUxMDg2ODk4OTY5OTQ0NjkyMDQ2MDU5MzIwNjYzNjY3MTc4MTYwMTI0MjQ0NzUzMjYzMDAxMzU2ODYwOTMzMDkyNDAxMzQ3MzgwNzIyODk2NzY1MjU5ODYyMTExODUzMzkxNjM5ODE0MjU1MjU5Njk2ODU2ODgyMTcxNDI4NDAzNzA2OTI4NDEwMTg3NDA3MDczODc2NzE0MDQ4NTg0MzI4MjcyMTk3NTQ1OTE0MDEyNzIzMzc3NDYyNTg0MDQ3OTY3ODc3NzY2NzEwMzU2ODc3NTE4ODg5OTU3MjA0NDAyMTQyNzQ2MjkxODM0MDQ1MzczNzE0MDQzMTc2OTQ5ODYzMDc0ODMxNDgyNTc4MjgwNDAxMDgyMjg2MDMyOTMyNzUyNDAxNzczMDUwMDUyNTEzMDEwNDg0MTgzNjExNjY0NzY3MjYwMjMzOTg0Mzc1OTg1MzQyODI5NTc0NTYyNzQxNDk1MDQ0MTgwNjkwNTI4ODk4Njk4NjAxNzc2Mzg0OTcwMjc3MTE1MzY5NDA0Mjc3OTE0MDk1NDA5MDY5MjYyOTQzNTY0MjA4ODI1Njk0OTY0MjIxNjY5MzIxMjYzMTA5NDAwMzM2MzgyMzgxOTY3MDA2OTc2MTY1MDYyOTI5MDc3NTE1OTU5ODg2NDIzODk2MjgzMDYxNzcwMDkzNTA0ODk0OTgyMzk1OTY5ODU5NjA=
###################################

# Enter your login:
# m4vre
# Your auth key:
# OTMyMjgxMTI4NTIyOTY2MDc3Mjg3NDY5MDI0MjkwOTEzNDY2NTEyMzkxNDgzMTEzNjQwNDM1NzUxNTY5NzU2MzA5ODU4ODI4MTY2OTY1OTA0MDM4NTQ4OTQ2MDk0NTA1MTM1ODQ5Mjc2OTQ5OTE5ODI5MzY1MDg2MzIwOTI5MTA5Mzg2NjI5ODU4MjY1MDEyNDAyOTY0OTQwNTk4Njc1NTM3NzY0MTcwODYwODc4MzYxMjk4ODg4MzY1NTc5NzkzNjM5MjM2NTUyNzk1NzA0NzgyNzMxMjEzNTc0Nzk1NDA2MjM5OTExMzYxMDM5MTcwNjk3Njc0NzQ5NjUwMjc5NDk3NzY5NjQ5MTE2ODY0MTQ5NzAyMzI0MTc2NjQzMTE0OTI0MDE0OTYyMzA5NDE2MTI0OTI1MTYxNjgwMjc4NTUwNDYzNDc2MTE5NDUwODEyODIzMjY0MjM1MzY3NjY5NjIwODQxNzUyMjI4ODEwMjM3Mzg5NTc3MjY0NzU1NzM2MjY4MDg1NDI4MzM5ODM4OTAyNjc1MTA0ODgxNzU2OTkwOTU5Njc4MDIxNjQ5MDg5MjA5MjI2ODUyMjU4NjUwNjY0NjAzODY5MTAwNzY1Mjk3NjcyNTM1MDU2Mjc0MDAyMDk4NjY5MDE2NTQ3OTg3OTMyOTU2MTExMjcyOTMxMzg5MjYyODE4ODAzODU3NjIzMzM2NjM5MTMzMjAxMTI3MDI5NDc3OTA1NzI4NDUwODQ5ODY0ODM1MTU1NDk5MDQ2MDAyMTc2NjkzOTQxNTQzMDY2NDM1NzI0NjAyMjgxNzkzNzk1NzcwMw==
###################################

# декодируем из Base64 и с помощью sage получаем приват ключ
# sage: HDFk = 20217757481809762858169265559245697337819236324412634416611707855582525694258986361724115108689896994469204605932066366717816012424475326300135686093309240134738072289676525986211185339163981425525969685688217142840370692841018740707387671404858432827219754591401272337746258404796787776671035687751888995720440214274629183404537371404317694986307483148257828040108228603293275240177305005251301048418361166476726023398437598534282957456274149504418069052889869860177638497027711536940427791409540906926294356420882569496422166932126310940033638238196700697616506292907751595988642389628306177009350489498239596985960
# sage: m4vre = 9322811285229660772874690242909134665123914831136404357515697563098588281669659040385489460945051358492769499198293650863209291093866298582650124029649405986755377641708608783612988883655797936392365527957047827312135747954062399113610391706976747496502794977696491168641497023241766431149240149623094161249251616802785504634761194508128232642353676696208417522288102373895772647557362680854283398389026751048817569909596780216490892092268522586506646038691007652976725350562740020986690165479879329561112729313892628188038576233366391332011270294779057284508498648351554990460021766939415430664357246022817937957703
# sage: c = HDFk * m4vre
# sage: n = 24007134668077839318704239757833363695524302813772795891485519226984107072647247568832064425929097558895623559893945502194926707312564453230806425423424997149843823227221596369795583261387779649714834167992749218150200223683296423069590080742550774828141844004559612066990484264910946488068587829100994639319674561758961812687482393281457478086918858906261630888892035335571465704005412337006332665433676386472229329420439767309647448615375682557274786037161968945400623209502352428011196477777002370787813952767888262642821196216644015950350716009261032012403125915949137853338061422774091806367454086620172463286011
# sage: d = c % n
# sage: d
# 13574623912432240044822863812359283234859747054148159494167235793917678319412072444049220920878999004683366385825155698767760556797615066283417123606928385652060060105820138620728285638496912124805566477509535383074533513156122531232065826370773868088087444815382738938881580869082664659745993055583125491761462132535762521732243362070654723892827301858921446245233115836311936507425056946162395221057250160140532999076594373669854001012508803090254776204137540070507399407964736897613474767804984570580214311552244341901130144736560242966070953745838499808795280677707289411139719908808829636035822691459884636879416
# sage: import base64
# sage: base64.b64encode(str(d))
# 'MTM1NzQ2MjM5MTI0MzIyNDAwNDQ4MjI4NjM4MTIzNTkyODMyMzQ4NTk3NDcwNTQxNDgxNTk0OTQxNjcyMzU3OTM5MTc2NzgzMTk0MTIwNzI0NDQwNDkyMjA5MjA4Nzg5OTkwMDQ2ODMzNjYzODU4MjUxNTU2OTg3Njc3NjA1NTY3OTc2MTUwNjYyODM0MTcxMjM2MDY5MjgzODU2NTIwNjAwNjAxMDU4MjAxMzg2MjA3MjgyODU2Mzg0OTY5MTIxMjQ4MDU1NjY0Nzc1MDk1MzUzODMwNzQ1MzM1MTMxNTYxMjI1MzEyMzIwNjU4MjYzNzA3NzM4NjgwODgwODc0NDQ4MTUzODI3Mzg5Mzg4ODE1ODA4NjkwODI2NjQ2NTk3NDU5OTMwNTU1ODMxMjU0OTE3NjE0NjIxMzI1MzU3NjI1MjE3MzIyNDMzNjIwNzA2NTQ3MjM4OTI4MjczMDE4NTg5MjE0NDYyNDUyMzMxMTU4MzYzMTE5MzY1MDc0MjUwNTY5NDYxNjIzOTUyMjEwNTcyNTAxNjAxNDA1MzI5OTkwNzY1OTQzNzM2Njk4NTQwMDEwMTI1MDg4MDMwOTAyNTQ3NzYyMDQxMzc1NDAwNzA1MDczOTk0MDc5NjQ3MzY4OTc2MTM0NzQ3Njc4MDQ5ODQ1NzA1ODAyMTQzMTE1NTIyNDQzNDE5MDExMzAxNDQ3MzY1NjAyNDI5NjYwNzA5NTM3NDU4Mzg0OTk4MDg3OTUyODA2Nzc3MDcyODk0MTExMzk3MTk5MDg4MDg4Mjk2MzYwMzU4MjI2OTE0NTk4ODQ2MzY4Nzk0MTY='

# затем
# Login:
# admin357
# Auth key:
# MTM1NzQ2MjM5MTI0MzIyNDAwNDQ4MjI4NjM4MTIzNTkyODMyMzQ4NTk3NDcwNTQxNDgxNTk0OTQxNjcyMzU3OTM5MTc2NzgzMTk0MTIwNzI0NDQwNDkyMjA5MjA4Nzg5OTkwMDQ2ODMzNjYzODU4MjUxNTU2OTg3Njc3NjA1NTY3OTc2MTUwNjYyODM0MTcxMjM2MDY5MjgzODU2NTIwNjAwNjAxMDU4MjAxMzg2MjA3MjgyODU2Mzg0OTY5MTIxMjQ4MDU1NjY0Nzc1MDk1MzUzODMwNzQ1MzM1MTMxNTYxMjI1MzEyMzIwNjU4MjYzNzA3NzM4NjgwODgwODc0NDQ4MTUzODI3Mzg5Mzg4ODE1ODA4NjkwODI2NjQ2NTk3NDU5OTMwNTU1ODMxMjU0OTE3NjE0NjIxMzI1MzU3NjI1MjE3MzIyNDMzNjIwNzA2NTQ3MjM4OTI4MjczMDE4NTg5MjE0NDYyNDUyMzMxMTU4MzYzMTE5MzY1MDc0MjUwNTY5NDYxNjIzOTUyMjEwNTcyNTAxNjAxNDA1MzI5OTkwNzY1OTQzNzM2Njk4NTQwMDEwMTI1MDg4MDMwOTAyNTQ3NzYyMDQxMzc1NDAwNzA1MDczOTk0MDc5NjQ3MzY4OTc2MTM0NzQ3Njc4MDQ5ODQ1NzA1ODAyMTQzMTE1NTIyNDQzNDE5MDExMzAxNDQ3MzY1NjAyNDI5NjYwNzA5NTM3NDU4Mzg0OTk4MDg3OTUyODA2Nzc3MDcyODk0MTExMzk3MTk5MDg4MDg4Mjk2MzYwMzU4MjI2OTE0NTk4ODQ2MzY4Nzk0MTY=
# You win!
# Flag is: h0W_did_YoU_hAck_RSA
###################################


#####################################
### Перебор AES алгоритма
#####################################
### условие
#    We found the source code for this robot encryption service, except the key was redacted from it. The service is currently running at 23.21.15.166:4433
#    Title: Encryption Service (300)
#    Category: Password Guessing
### Мысли
"""
    The service basically implements an encryption Oracle, it reads data from the socket and returns the AES-CBC encrypted
    version of this data, concatenated with a secret string. The challenge is to find this secret string.

    Mulitple blocks can be submitted where the ciphertext of the previous block will be used as the IV for the next.
    The IV for the first block is randomly generated and sent to the client by the server. Data is encrypted in blocks of
    16 bytes (128 bits). The output provided is the encrypted version of <input> + <level_key> + <padding>.

    So how do we find the hidden challenge key… Let’s look at what happens if we supply input AAAA.
    In that case the input to AES looks as follows:

            block 1     |      block 2      |      block 3      |
            AAAA xxxx xxxx xxxx|xxxx xxxx xxxx xxxx|xppp pppp pppp pppp|

    In this example the x’s represent characters from the secret key and p are padding characters.
    In this case there is only one unknown byte in the third block which is the last character of the key.
    If we store the encrypted version of this block we can simply implement a linear search by first encrypting
    appp pppp pppp pppp, then bppp pppp pppp pppp, then cppp pppp pppp pppp, etc. Until we get an encrypted block
    which is equal to the block we are searching for.

    There is one slight complication here which are the IVs, which are meant to make sure that the same input doesn’t
    always encrypt to the same output. However the IV for the third block, which we are searching for, is simlpy the
    ciphertext of the previous block. So in practice the third block looks like this:

            (xppp pppp pppp pppp) xor (cipher_text_second_block)

    So if we submit (appp pppp pppp pppp) xor (cipher_text_second_block) xor (next_iv) where a is our guess for the last
    character of the key we receive the same output if a was guessed correctly.

    The nice thing about this approach, is that we can keep repeating it to reveal the next character of the key,
    for example to find the second character of the key we use input AAAAA which will yield the following encrypted block:

            block 1     |      block 2      |      block 3      |
            AAAA Axxx xxxx xxxx|xxxx xxxx xxxx xxxx|xxpp pppp pppp pppp|

    Since the last character of the key is known from the previous step we are again only left with a limited number
    of possibilities. This process can be repeated to reveal the entire key.

    We implemented the attack in python:
"""

def sample_Aes():
    import socket,struct,sys,string
    def make(data):
        return struct.pack('I',len(data)) + data

    def pad(data, blocksize=16):
        l = blocksize - (len(data) % blocksize)
        return data + chr(l) * l

    def get_enc(data):
        global s
        s.send(make(data))
        l = struct.unpack("I",s.recv(4))[0]
        data = s.recv(l)
        return data

    def string_xor(a,key):
        return ''.join(chr(ord(a[i]) ^ ord(key[i%len(key)])) for i in range(len(a)))

    def attack(key):
        global s
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect(('174.129.168.125', 4433))

        iv = s.recv(16)
        prefix = "A" * (4+len(key))
        enc = get_enc(prefix)
        third_block = enc[32:32+16]
        third_iv = enc[16:16+16]

        search = third_block
        print "Search block: %s" % search.encode('hex')

        iv = enc[-16:]

        for x in string.lowercase + '_':
            guess = string_xor(pad(x+key),third_iv)
            new = get_enc(string_xor(guess,iv))
            lb = new[:16]
            if lb == search:
                return x
            iv = new[-16:]


    key=''
    for x in range(29):
        new = attack(key)
        key = new + key
        print "Found: " + key

"""
    Running this program reveals the key:

            Search block: 107b4efae8d1befa1df39a0802fa6c1d
            Found: s
            Search block: afdfde9db5a44df21a84a089a9083f53
            Found: us
            Search block: eb632f01027fe10685716e9ecac582f5
            Found: ous
            ...
            Found: edictable_ivs_are_dangerous
            Search block: ad04e566628430aea3628fe85de85189
            Found: redictable_ivs_are_dangerous
            Search block: da429ea307dae8d1c2e58895545b004f
            Found: predictable_ivs_are_dangerous
"""


sample_bruteThreadin()