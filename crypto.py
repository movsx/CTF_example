# -*- coding: utf-8 -*-
import sys
### Merkle–Hellman knapsack cryptosystem
# условие
"""
def generate_public_key(private_key):
	n = 199285318978668966527551342512997250816637709274749259983292077699440369
	t = 32416190071
	return list(map(lambda x: (t * x) % n, private_key))

def crypt(open_text, public_key):
	bts = []
	[bts.extend([int(b) for b in '00000000'[len(bin(ord(c))[2:]):] + bin(ord(c))[2:]]) for c in open_text]
	return [sum(map(lambda x: x[0] * x[1] ,zip(blk, public_key))) for blk in [bts[i * 128:(i+1) * 128] for i in range(len(open_text) // 16)]]

public_key = [1050809378719198985041, 2101618757438397970082, 6304856272315193910246, 18914568816945581730738, 56743706450836745192214, 170231119352510235576642, 510693358057530706729926, 1532080074172592120189778, 4596240222517776360569334, 13788720667553329081708002, 41366162002659987245124006, 124098486007979961735372018, 372295458023939885206116054, 1116886374071819655618348162, 3350659122215458966855044486, 10051977366646376900565133458, 30155932099939130701695400374, 90467796299817392105086201122, 271403388899452176315258603366, 814210166698356528945775810098, 2442630500095069586837327430294, 7327891500285208760511982290882, 21983674500855626281535946872646, 65951023502566878844607840617938, 197853070507700636533823521853814, 593559211523101909601470565561442, 1780677634569305728804411696684326, 5342032903707917186413235090052978, 16026098711123751559239705270158934, 48078296133371254677719115810476802, 144234888400113764033157347431430406, 432704665200341292099472042294291218, 1298113995601023876298416126882873654, 3894341986803071628895248380648620962, 11683025960409214886685745141945862886, 35049077881227644660057235425837588658, 105147233643682933980171706277512765974, 315441700931048801940515118832538297922, 946325102793146405821545356497614893766, 2838975308379439217464636069492844681298, 8516925925138317652393908208478534043894, 25550777775414952957181724625435602131682, 76652333326244858871545173876306806395046, 229956999978734576614635521628920419185138, 689870999936203729843906564886761257555414, 2069612999808611189531719694660283772666242, 6208838999425833568595159083980851317998726, 18626516998277500705785477251942553953996178, 55879550994832502117356431755827661861988534, 167638652984497506352069295267482985585965602, 502915958953492519056207885802448956757896806, 1508747876860477557168623657407346870273690418, 4526243630581432671505870972222040610821071254, 13578730891744298014517612916666121832463213762, 40736192675232894043552838749998365497389641286, 122208578025698682130658516249995096492168923858, 366625734077096046391975548749985289476506771574, 1099877202231288139175926646249955868429520314722, 3299631606693864417527779938749867605288560944166, 9898894820081593252583339816249602815865682832498, 29696684460244779757750019448748808447597048497494, 89090053380734339273250058346246425342791145492482, 267270160142203017819750175038739276028373436477446, 801810480426609053459250525116217828085120309432338, 2405431441279827160377751575348653484255360928297014, 7216294323839481481133254726045960452766082784891042, 21648882971518444443399764178137881358298248354673126, 64946648914555333330199292534413644074894745064019378, 194839946743665999990597877603240932224684235192058134, 584519840230997999971793632809722796674052705576174402, 1753559520692993999915380898429168390022158116728523206, 5260678562078981999746142695287505170066474350185569618, 15782035686236945999238428085862515510199423050556708854, 47346107058710837997715284257587546530598269151670126562, 142038321176132513993145852772762639591794807455010379686, 426114963528397541979437558318287918775384422365031139058, 1278344890585192625938312674954863756326153267095093417174, 3835034671755577877814938024864591268978459801285280251522, 11505104015266733633444814074593773806935379403855840754566, 34515312045800200900334442223781321420806138211567522263698, 103545936137400602701003326671343964262418414634702566791094, 310637808412201808103009980014031892787255243904107700373282, 931913425236605424309029940042095678361765731712323101119846, 2795740275709816272927089820126287035085297195136969303359538, 8387220827129448818781269460378861105255891585410907910078614, 25161662481388346456343808381136583315767674756232723730235842, 75484987444165039369031425143409749947303024268698171190707526, 226454962332495118107094275430229249841909072806094513572122578, 679364886997485354321282826290687749525727218418283540716367734, 2038094660992456062963848478872063248577181655254850622149103202, 6114283982977368188891545436616189745731544965764551866447309606, 18342851948932104566674636309848569237194634897293655599341928818, 55028555846796313700023908929545707711583904691880966798025786454, 165085667540388941100071726788637123134751714075642900394077359362, 495257002621166823300215180365911369404255142226928701182232078086, 1485771007863500469900645541097734108212765426680786103546696234258, 4457313023590501409701936623293202324638296280042358310640088702774, 13371939070771504229105809869879606973914888840127074931920266108322, 40115817212314512687317429609638820921744666520381224795760798324966, 120347451636943538061952288828916462765233999561143674387282394974898, 361042354910830614185856866486749388295701998683431023161847184924694, 1083127064732491842557570599460248164887105996050293069485541554774082, 3249381194197475527672711798380744494661317988150879208456624664322246, 9748143582592426583018135395142233483983953964452637625369873992966738, 29244430747777279749054406185426700451951861893357912876109621978900214, 87733292243331839247163218556280101355855585680073738628328865936700642, 63914557751326551213938313155843053250929047765471955901694520110661557, 191743673253979653641814939467529159752787143296415867705083560331984671, 176660381804601027870342133376592977625086011339749083148666525597073275, 131410507456465150555923715103784431241982615469748729479415421392339087, 194946203390726485140219802798356042909310137134496928454954186477576892, 186267972214841522365556723369073627094654992853992265398278404033849938, 160233278687186634041567485081226379650689560012478276228251056702669076, 82129198104221969069599770217684637318793261487936308718169014709126490, 47102275333996940681247968140056661139742075189059666171214966427939101, 141306826001990822043743904420169983419226225567178998513644899283817303, 25349840048634533076129028234515448624403258152038475574350542452571171, 76049520145903599228387084703546345873209774456115426723051627357713513, 28863241459041831157609911597641786802991614093597020185862804373700170, 86589724377125493472829734792925360408974842280791060557588413121100510, 60483854152707513890937861865778830410286817567623921689473161663861161, 181451562458122541672813585597336491230860452702871765068419484991583483, 145784049417029691963338071766014972059305939559116775238674299575869711, 38781510293751142834911530272050414544642400127851805749438743328728395, 116344530881253428504734590816151243633927200383555417248316229986185185, 149748273665091318986652429935456480085143891875916991761656612259115186, 50674183037936023904854604780374938622156257078252455318385681378464820, 152022549113808071714563814341124815866468771234757365955157044135394460]
cipher_text =
	[
		1387977778999926469357780220487630125151962348185941993910077394771302677,
		1192236960845781949613172279312582839292898077268409678421304772227241438,
		1295152741157953792099179799985052248167548374589648818528421499250916999,
		828724787424187908000366458781164595076558885463707900320215679908512646,
		1179926879709109047038661681316962368287877340885819899201698611790531134,
		965171312356484716595815857561729919489896088681139239093293829323154838,
		1099367377207651843612375443021502714028353049437532392256489525051038347,
		1374891605015623267623322424512489936836885983493815443812918444687247914,
		1152880248428103510879661300981452627677389745079857275081612568623556291,
		962409003220820525413536841942678826309419979028794415812582008820263317
	]
"""
# решение 1
def Merkle():
    n = 199285318978668966527551342512997250816637709274749259983292077699440369
    t = 32416190071
    public_key = [ 1050809378719198985041, 2101618757438397970082, 6304856272315193910246, 18914568816945581730738, 56743706450836745192214, 170231119352510235576642, 510693358057530706729926, 1532080074172592120189778, 4596240222517776360569334, 13788720667553329081708002, 41366162002659987245124006, 124098486007979961735372018, 372295458023939885206116054, 1116886374071819655618348162, 3350659122215458966855044486, 10051977366646376900565133458, 30155932099939130701695400374, 90467796299817392105086201122, 271403388899452176315258603366, 814210166698356528945775810098, 2442630500095069586837327430294, 7327891500285208760511982290882, 21983674500855626281535946872646, 65951023502566878844607840617938, 197853070507700636533823521853814, 593559211523101909601470565561442, 1780677634569305728804411696684326, 5342032903707917186413235090052978, 16026098711123751559239705270158934, 48078296133371254677719115810476802, 144234888400113764033157347431430406, 432704665200341292099472042294291218, 1298113995601023876298416126882873654, 3894341986803071628895248380648620962, 11683025960409214886685745141945862886, 35049077881227644660057235425837588658, 105147233643682933980171706277512765974, 315441700931048801940515118832538297922, 946325102793146405821545356497614893766, 2838975308379439217464636069492844681298, 8516925925138317652393908208478534043894, 25550777775414952957181724625435602131682, 76652333326244858871545173876306806395046, 229956999978734576614635521628920419185138, 689870999936203729843906564886761257555414, 2069612999808611189531719694660283772666242, 6208838999425833568595159083980851317998726, 18626516998277500705785477251942553953996178, 55879550994832502117356431755827661861988534, 167638652984497506352069295267482985585965602, 502915958953492519056207885802448956757896806, 1508747876860477557168623657407346870273690418, 4526243630581432671505870972222040610821071254, 13578730891744298014517612916666121832463213762, 40736192675232894043552838749998365497389641286, 122208578025698682130658516249995096492168923858, 366625734077096046391975548749985289476506771574, 1099877202231288139175926646249955868429520314722, 3299631606693864417527779938749867605288560944166, 9898894820081593252583339816249602815865682832498, 29696684460244779757750019448748808447597048497494, 89090053380734339273250058346246425342791145492482, 267270160142203017819750175038739276028373436477446, 801810480426609053459250525116217828085120309432338, 2405431441279827160377751575348653484255360928297014, 7216294323839481481133254726045960452766082784891042, 21648882971518444443399764178137881358298248354673126, 64946648914555333330199292534413644074894745064019378, 194839946743665999990597877603240932224684235192058134, 584519840230997999971793632809722796674052705576174402, 1753559520692993999915380898429168390022158116728523206, 5260678562078981999746142695287505170066474350185569618, 15782035686236945999238428085862515510199423050556708854, 47346107058710837997715284257587546530598269151670126562, 142038321176132513993145852772762639591794807455010379686, 426114963528397541979437558318287918775384422365031139058, 1278344890585192625938312674954863756326153267095093417174, 3835034671755577877814938024864591268978459801285280251522, 11505104015266733633444814074593773806935379403855840754566, 34515312045800200900334442223781321420806138211567522263698, 103545936137400602701003326671343964262418414634702566791094, 310637808412201808103009980014031892787255243904107700373282, 931913425236605424309029940042095678361765731712323101119846, 2795740275709816272927089820126287035085297195136969303359538, 8387220827129448818781269460378861105255891585410907910078614, 25161662481388346456343808381136583315767674756232723730235842, 75484987444165039369031425143409749947303024268698171190707526, 226454962332495118107094275430229249841909072806094513572122578, 679364886997485354321282826290687749525727218418283540716367734, 2038094660992456062963848478872063248577181655254850622149103202, 6114283982977368188891545436616189745731544965764551866447309606, 18342851948932104566674636309848569237194634897293655599341928818, 55028555846796313700023908929545707711583904691880966798025786454, 165085667540388941100071726788637123134751714075642900394077359362, 495257002621166823300215180365911369404255142226928701182232078086, 1485771007863500469900645541097734108212765426680786103546696234258, 4457313023590501409701936623293202324638296280042358310640088702774, 13371939070771504229105809869879606973914888840127074931920266108322, 40115817212314512687317429609638820921744666520381224795760798324966, 120347451636943538061952288828916462765233999561143674387282394974898, 361042354910830614185856866486749388295701998683431023161847184924694, 1083127064732491842557570599460248164887105996050293069485541554774082, 3249381194197475527672711798380744494661317988150879208456624664322246, 9748143582592426583018135395142233483983953964452637625369873992966738, 29244430747777279749054406185426700451951861893357912876109621978900214, 87733292243331839247163218556280101355855585680073738628328865936700642, 63914557751326551213938313155843053250929047765471955901694520110661557, 191743673253979653641814939467529159752787143296415867705083560331984671, 176660381804601027870342133376592977625086011339749083148666525597073275, 131410507456465150555923715103784431241982615469748729479415421392339087, 194946203390726485140219802798356042909310137134496928454954186477576892, 186267972214841522365556723369073627094654992853992265398278404033849938, 160233278687186634041567485081226379650689560012478276228251056702669076, 82129198104221969069599770217684637318793261487936308718169014709126490, 47102275333996940681247968140056661139742075189059666171214966427939101, 141306826001990822043743904420169983419226225567178998513644899283817303, 25349840048634533076129028234515448624403258152038475574350542452571171, 76049520145903599228387084703546345873209774456115426723051627357713513, 28863241459041831157609911597641786802991614093597020185862804373700170, 86589724377125493472829734792925360408974842280791060557588413121100510, 60483854152707513890937861865778830410286817567623921689473161663861161, 181451562458122541672813585597336491230860452702871765068419484991583483, 145784049417029691963338071766014972059305939559116775238674299575869711, 38781510293751142834911530272050414544642400127851805749438743328728395, 116344530881253428504734590816151243633927200383555417248316229986185185, 149748273665091318986652429935456480085143891875916991761656612259115186, 50674183037936023904854604780374938622156257078252455318385681378464820, 152022549113808071714563814341124815866468771234757365955157044135394460 ]
    cipher_text = [ 1387977778999926469357780220487630125151962348185941993910077394771302677, 1192236960845781949613172279312582839292898077268409678421304772227241438, 1295152741157953792099179799985052248167548374589648818528421499250916999, 828724787424187908000366458781164595076558885463707900320215679908512646, 1179926879709109047038661681316962368287877340885819899201698611790531134, 965171312356484716595815857561729919489896088681139239093293829323154838, 1099367377207651843612375443021502714028353049437532392256489525051038347, 1374891605015623267623322424512489936836885983493815443812918444687247914, 1152880248428103510879661300981452627677389745079857275081612568623556291, 962409003220820525413536841942678826309419979028794415812582008820263317 ]
    private_key = [ t ] + [ t * 2 * 3 ** i for i in xrange( 0, 127 ) ]
    t2inv = 113733348753781020783170490400630827179237386517084745662682984487937812

    def dec( block ):
        r = ''
        ohlol = t2inv * block % n
        if ohlol % 2 == 1:
            r += '1'
            ohlol -= 1
        ohlol /= 2
        for i in xrange( 1, 128 ):
            r += '%s' % (ohlol % 3 ** i / 3 ** (i - 1))
        return hex( int( r, 2 ) )[ 2: ].rstrip( 'L' ).decode( 'hex' )

    for c in cipher_text:
        try:
            sys.stdout.write( dec( c ) )
        except:
            print 'FAIL'

# решение 2
"""
This is what we got when analysing the public_key list:

    sage: factor(1050809378719198985041)
    32416190071^2
    sage: factor(2101618757438397970082)
    2 * 32416190071^2
    sage: factor(6304856272315193910246)
    2 * 3 * 32416190071^2
    sage: factor(18914568816945581730738)
    2 * 3^2 * 32416190071^2
    sage: factor(56743706450836745192214)
    2 * 3^3 * 32416190071^2
    sage: factor(170231119352510235576642)
    2 * 3^4 * 32416190071^2

Looks like the private_key is generated based on the given 't' value. This is how we generated the private_key list

    private_key = [t]
    for i in range(0,127):
        private_key.append(2 * 3**i * t)

The generated private keys can be verified using the given generate_public_key() function. We got a match. Then we wrote the routine for inverse knapsack sum to get the flag. Here is the final code:
"""
def Merkle2():
    n = 199285318978668966527551342512997250816637709274749259983292077699440369
    t = 32416190071
    t_inv = 3607086840002694423309872675805192458275553329397325526691156370525160 #sage: inverse_mod(t,n)

    private_key = [t]
    for i in range(0,127):
        private_key.append(2 * 3**i * t)

    cipher_text = [
      1387977778999926469357780220487630125151962348185941993910077394771302677,
      1192236960845781949613172279312582839292898077268409678421304772227241438,
      1295152741157953792099179799985052248167548374589648818528421499250916999,
      828724787424187908000366458781164595076558885463707900320215679908512646,
      1179926879709109047038661681316962368287877340885819899201698611790531134,
      965171312356484716595815857561729919489896088681139239093293829323154838,
      1099367377207651843612375443021502714028353049437532392256489525051038347,
      1374891605015623267623322424512489936836885983493815443812918444687247914,
      1152880248428103510879661300981452627677389745079857275081612568623556291,
      962409003220820525413536841942678826309419979028794415812582008820263317
           ]

    def decrypt(cipher, private_key):   # inverse knapsack

        bts = ['0']*128                 # generate bit string
        for i in range(len(private_key) - 1, -1, -1):
            if cipher >= private_key[i]:
                bts[i] = '1'
                cipher = cipher - private_key[i]

        for j in range(0,128,8):        # generate chars out of every 8-bits
            sys.stdout.write(chr(int(''.join(bts[j:j+8]),2)))

    for c in cipher_text:               # iterate through 10 blocks
        decrypt((c * t_inv) % n,private_key)
    print ''


### Пример взлома RSA методом факторизации Ферма на основе того, что в задаче p и q расположены близко друг к другу
# Ссылка на метод факторизации Ферма http://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D1%84%D0%B0%D0%BA%D1%82%D0%BE%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8_%D0%A4%D0%B5%D1%80%D0%BC%D0%B0
### Условие
# n = 52663327194823108047941861363554667296911056447871 88785127198792390818389767437741043884042697813417 40858276714053716810874389770623503703996736687974 70776186113807376857893834326388369431932515506157 59902933749676883316817097953054649047764645797986 77703632934375663507898357576891627341435121532539 03202593
# e = 10662335266334707061416010175090707752184800780484 87199510272395686606199019585683070878871806968902 65830636660853997681894517472390188901902543758517 09269
# cipher-text = 10462822375277205946365199641597262713749993739943 57909091506537398272791306618098458481620423392938 70744463265888874276961969971096108086452105647668 82647584743088857818448828460464362997716024535291 28094029803725929915632320170106381959701908835246 76285475884921692502194212799981792187650488093680 64725175
### Решение
# Since python's float->int casting is inaccurate, I used SAGE.
# An actual s=(p-q)/2 value was obtained from the very first iteration:
### Код:
# sage: r=ceil(sqrt(n))
# sage: t=r+0 #first iteration
# sage: s=sqrt(t**2-n)
# sage: s #should be integer
# 1754844
# sage: p=t-s
# sage: q=t+s
#sage: phi=(p-1)*(q-1)
# sage: d=pow(e,-1,phi)
# sage: pow(c,d,n)
# 22424170465
### The flag is 22424170465

### Пример взлома простых алгоритмов перебором
# Условие
# cipher-text     168 232 100 162 135 179 112 100 173 206 106 123 106 195 179 157 123 173
# Алгоритм шифрования
"""
    for ($i = 0; $i<strlen($str); $i++)
    $dec_array[] = ord($str{$i});
    $ar = $dec_array;
    $max = max($ar);

    $key = rand(10,$max);
    $key = 101*$key;

    for($i=0;$i<strlen($str);$i++){
    $x = $ar[$i];
    $am = ($key+$x)/2;
    $gm = sqrt($key*$x);
    $enc = $am + $gm;
    $encrypt = floor($enc)%255;
    echo $encrypt.' ';
    } """
### Решение (флаг: myalgocantbebroken)
import math
def sample_bruteenc():
    cipher = (168, 232, 100 ,162, 135, 179, 112, 100, 173, 206, 106, 123, 106, 195, 179, 157, 123, 173)
    for key in range (10,128):
        plain = []
        key_new = key * 101
        for i in range (0, len(cipher)):
            for p in range(32,128):
                x = p
                am = float(key_new+x)/2
                gm = math.sqrt(key_new*x)
                enc = am + gm
                encrypt = int(enc)%255
                if(encrypt == cipher[i]):
                    plain.append(p) #array_push($plain,$p);
        if(len(plain) == len(cipher)):
            print ''.join( [chr(t) for t in plain] )

### Еще один пример перебора, но уже с использованием RSA
# Условие
# Алгоритм
"""
    cmd = raw_input('[0] Get auth key\n[1] Login\n[2] Exit\n').strip()
    if cmd == '0':
        login = raw_input('Enter your login:\n').strip()
        if re.search('[^a-zA-Z0-9]', login):
            print 'Bad login'
            continue
        if login == self.admin:
            print 'Not for admins!'
        elif len(login) < self.max_login_len:
            m = self.str_to_hash(login)
            auth_key = self.binpow(m, self.d, self.n)
            print 'Your auth key:\n%s' % base64.b64encode(str(auth_key))
        else:
            print 'Error'
    elif cmd == '1':
        login = raw_input('Login:\n').strip()
        auth_key = raw_input('Auth key:\n').strip()
        try:
            auth_key = int(base64.b64decode(auth_key))
        except:
            print 'Error'
            continue
        c = self.str_to_hash(login)
        if c == self.binpow(auth_key, self.e, self.n):
            if login == self.admin:
                flag = open('flag.txt','r').readline().strip()
                print 'You win!\nFlag is: %s' % flag
            else:
                print 'Welcome, %s! You are not admin' % login
        else:
            print 'Wrong auth key!'
    elif cmd == '2':
        sys.exit(0)
"""
### Мысли
# Summary of service:
# [*] The service calculates the hash value of login name
# [*] Then signs on the hash value as hash(m)^d mod n. This is sent back as authorization key
#[*] The service doesn't sign when the login name is 'admin357'
# [*] We will get flag if we could forge the signature of 'admin357' and validate ourself as admin
#
# The public exponent e and modulo n value are given. Private exponent d is unknown.
#
# e = 65537
# n = 24007134668077839318704239757833363695524302813772795891485519226984107072647247568832064425929097558895623559893945502194926707312564453230806425423424997149843823227221596369795583261387779649714834167992749218150200223683296423069590080742550774828141844004559612066990484264910946488068587829100994639319674561758961812687482393281457478086918858906261630888892035335571465704005412337006332665433676386472229329420439767309647448615375682557274786037161968945400623209502352428011196477777002370787813952767888262642821196216644015950350716009261032012403125915949137853338061422774091806367454086620172463286011

# After some googling I came across this paper How Not to Design RSA Signature Schemes. It gave good summary of attacks on RSA system.
# Page 8 describes The Desmedt and Odlyzko Attack against RSA Signatures that use Hash Function. This is what the attack says

# [*] It applies to signatures when messages to sign are relatively small
# [*] Factor the message we wish to forge into small primes
# [*] Obtain signatures for these small primes [ Sig(m1) and Sig(m2) ]
# [*] Produce the signature by multiplying the factors signature [ Sig('admin357') = Sig(m1)) * Sig(m2) mod n ]

# This method looked much feasible and relevant for this particular challenge. We do the above steps to get the flag.
# Using the hash function defined in source code, we find the hash value of 'admin357' as 240021000768277

# sage: factor(240021000768277)
# 2879449 * 83356573

# Now we should find the two messages whose hash values are 2879449 and 83356573. For this, write a bruteforcer
### Брутфорсер с потокамм

from multiprocessing import Process
import string

charset = map(chr,range(ord('a'),ord('z')+1)+range(ord('A'),ord('Z')+1)+range(ord('0'),ord('9')+1)) # устанавливаем множество символов
p = len(charset)+1
sec_option = string.ascii_letters + string.digits
threads = 10
size = len(sec_option)/threads

def find_login(start, end):
    for i in sec_option[start:end]:
        for j in sec_option:
            for k in sec_option:
                for l in sec_option:
                    for m in sec_option:
                        s = i + j + k + l + m
                        res = 0
                        p_pow = 1
                        for ch in s:
                            res = res + (charset.index(ch) + 1) * p_pow
                            p_pow = p_pow * p
                        if res == 83356573: # печатаем резудьтат для m4vre
                            print "hash ",s,"= 83356573"
                        if res == 2879449: # печатаем резудьтат для HDFk
                            print "hash ",s,"= 2879449"

def sample_bruteThreadin():
    for i in range(threads):
        if i == threads - 1:
            pro = Process(target=find_login, args=(end, len(sec_option)))
        else:
            start = i*size
            end = (i+1)*size
            pro = Process(target=find_login, args=(start, end))
        pro.start()

# hash(HDFk)  == 2879449
# hash(m4vre) == 83356573

# Now find the signatures of these two messages:

# Enter your login:
# HDFk
# Your auth key:
# MjAyMTc3NTc0ODE4MDk3NjI4NTgxNjkyNjU1NTkyNDU2OTczMzc4MTkyMzYzMjQ0MTI2MzQ0MTY2MTE3MDc4NTU1ODI1MjU2OTQyNTg5ODYzNjE3MjQxMTUxMDg2ODk4OTY5OTQ0NjkyMDQ2MDU5MzIwNjYzNjY3MTc4MTYwMTI0MjQ0NzUzMjYzMDAxMzU2ODYwOTMzMDkyNDAxMzQ3MzgwNzIyODk2NzY1MjU5ODYyMTExODUzMzkxNjM5ODE0MjU1MjU5Njk2ODU2ODgyMTcxNDI4NDAzNzA2OTI4NDEwMTg3NDA3MDczODc2NzE0MDQ4NTg0MzI4MjcyMTk3NTQ1OTE0MDEyNzIzMzc3NDYyNTg0MDQ3OTY3ODc3NzY2NzEwMzU2ODc3NTE4ODg5OTU3MjA0NDAyMTQyNzQ2MjkxODM0MDQ1MzczNzE0MDQzMTc2OTQ5ODYzMDc0ODMxNDgyNTc4MjgwNDAxMDgyMjg2MDMyOTMyNzUyNDAxNzczMDUwMDUyNTEzMDEwNDg0MTgzNjExNjY0NzY3MjYwMjMzOTg0Mzc1OTg1MzQyODI5NTc0NTYyNzQxNDk1MDQ0MTgwNjkwNTI4ODk4Njk4NjAxNzc2Mzg0OTcwMjc3MTE1MzY5NDA0Mjc3OTE0MDk1NDA5MDY5MjYyOTQzNTY0MjA4ODI1Njk0OTY0MjIxNjY5MzIxMjYzMTA5NDAwMzM2MzgyMzgxOTY3MDA2OTc2MTY1MDYyOTI5MDc3NTE1OTU5ODg2NDIzODk2MjgzMDYxNzcwMDkzNTA0ODk0OTgyMzk1OTY5ODU5NjA=
###################################

# Enter your login:
# m4vre
# Your auth key:
# OTMyMjgxMTI4NTIyOTY2MDc3Mjg3NDY5MDI0MjkwOTEzNDY2NTEyMzkxNDgzMTEzNjQwNDM1NzUxNTY5NzU2MzA5ODU4ODI4MTY2OTY1OTA0MDM4NTQ4OTQ2MDk0NTA1MTM1ODQ5Mjc2OTQ5OTE5ODI5MzY1MDg2MzIwOTI5MTA5Mzg2NjI5ODU4MjY1MDEyNDAyOTY0OTQwNTk4Njc1NTM3NzY0MTcwODYwODc4MzYxMjk4ODg4MzY1NTc5NzkzNjM5MjM2NTUyNzk1NzA0NzgyNzMxMjEzNTc0Nzk1NDA2MjM5OTExMzYxMDM5MTcwNjk3Njc0NzQ5NjUwMjc5NDk3NzY5NjQ5MTE2ODY0MTQ5NzAyMzI0MTc2NjQzMTE0OTI0MDE0OTYyMzA5NDE2MTI0OTI1MTYxNjgwMjc4NTUwNDYzNDc2MTE5NDUwODEyODIzMjY0MjM1MzY3NjY5NjIwODQxNzUyMjI4ODEwMjM3Mzg5NTc3MjY0NzU1NzM2MjY4MDg1NDI4MzM5ODM4OTAyNjc1MTA0ODgxNzU2OTkwOTU5Njc4MDIxNjQ5MDg5MjA5MjI2ODUyMjU4NjUwNjY0NjAzODY5MTAwNzY1Mjk3NjcyNTM1MDU2Mjc0MDAyMDk4NjY5MDE2NTQ3OTg3OTMyOTU2MTExMjcyOTMxMzg5MjYyODE4ODAzODU3NjIzMzM2NjM5MTMzMjAxMTI3MDI5NDc3OTA1NzI4NDUwODQ5ODY0ODM1MTU1NDk5MDQ2MDAyMTc2NjkzOTQxNTQzMDY2NDM1NzI0NjAyMjgxNzkzNzk1NzcwMw==
###################################

# декодируем из Base64 и с помощью sage получаем приват ключ
# sage: HDFk = 20217757481809762858169265559245697337819236324412634416611707855582525694258986361724115108689896994469204605932066366717816012424475326300135686093309240134738072289676525986211185339163981425525969685688217142840370692841018740707387671404858432827219754591401272337746258404796787776671035687751888995720440214274629183404537371404317694986307483148257828040108228603293275240177305005251301048418361166476726023398437598534282957456274149504418069052889869860177638497027711536940427791409540906926294356420882569496422166932126310940033638238196700697616506292907751595988642389628306177009350489498239596985960
# sage: m4vre = 9322811285229660772874690242909134665123914831136404357515697563098588281669659040385489460945051358492769499198293650863209291093866298582650124029649405986755377641708608783612988883655797936392365527957047827312135747954062399113610391706976747496502794977696491168641497023241766431149240149623094161249251616802785504634761194508128232642353676696208417522288102373895772647557362680854283398389026751048817569909596780216490892092268522586506646038691007652976725350562740020986690165479879329561112729313892628188038576233366391332011270294779057284508498648351554990460021766939415430664357246022817937957703
# sage: c = HDFk * m4vre
# sage: n = 24007134668077839318704239757833363695524302813772795891485519226984107072647247568832064425929097558895623559893945502194926707312564453230806425423424997149843823227221596369795583261387779649714834167992749218150200223683296423069590080742550774828141844004559612066990484264910946488068587829100994639319674561758961812687482393281457478086918858906261630888892035335571465704005412337006332665433676386472229329420439767309647448615375682557274786037161968945400623209502352428011196477777002370787813952767888262642821196216644015950350716009261032012403125915949137853338061422774091806367454086620172463286011
# sage: d = c % n
# sage: d
# 13574623912432240044822863812359283234859747054148159494167235793917678319412072444049220920878999004683366385825155698767760556797615066283417123606928385652060060105820138620728285638496912124805566477509535383074533513156122531232065826370773868088087444815382738938881580869082664659745993055583125491761462132535762521732243362070654723892827301858921446245233115836311936507425056946162395221057250160140532999076594373669854001012508803090254776204137540070507399407964736897613474767804984570580214311552244341901130144736560242966070953745838499808795280677707289411139719908808829636035822691459884636879416
# sage: import base64
# sage: base64.b64encode(str(d))
# 'MTM1NzQ2MjM5MTI0MzIyNDAwNDQ4MjI4NjM4MTIzNTkyODMyMzQ4NTk3NDcwNTQxNDgxNTk0OTQxNjcyMzU3OTM5MTc2NzgzMTk0MTIwNzI0NDQwNDkyMjA5MjA4Nzg5OTkwMDQ2ODMzNjYzODU4MjUxNTU2OTg3Njc3NjA1NTY3OTc2MTUwNjYyODM0MTcxMjM2MDY5MjgzODU2NTIwNjAwNjAxMDU4MjAxMzg2MjA3MjgyODU2Mzg0OTY5MTIxMjQ4MDU1NjY0Nzc1MDk1MzUzODMwNzQ1MzM1MTMxNTYxMjI1MzEyMzIwNjU4MjYzNzA3NzM4NjgwODgwODc0NDQ4MTUzODI3Mzg5Mzg4ODE1ODA4NjkwODI2NjQ2NTk3NDU5OTMwNTU1ODMxMjU0OTE3NjE0NjIxMzI1MzU3NjI1MjE3MzIyNDMzNjIwNzA2NTQ3MjM4OTI4MjczMDE4NTg5MjE0NDYyNDUyMzMxMTU4MzYzMTE5MzY1MDc0MjUwNTY5NDYxNjIzOTUyMjEwNTcyNTAxNjAxNDA1MzI5OTkwNzY1OTQzNzM2Njk4NTQwMDEwMTI1MDg4MDMwOTAyNTQ3NzYyMDQxMzc1NDAwNzA1MDczOTk0MDc5NjQ3MzY4OTc2MTM0NzQ3Njc4MDQ5ODQ1NzA1ODAyMTQzMTE1NTIyNDQzNDE5MDExMzAxNDQ3MzY1NjAyNDI5NjYwNzA5NTM3NDU4Mzg0OTk4MDg3OTUyODA2Nzc3MDcyODk0MTExMzk3MTk5MDg4MDg4Mjk2MzYwMzU4MjI2OTE0NTk4ODQ2MzY4Nzk0MTY='

# затем
# Login:
# admin357
# Auth key:
# MTM1NzQ2MjM5MTI0MzIyNDAwNDQ4MjI4NjM4MTIzNTkyODMyMzQ4NTk3NDcwNTQxNDgxNTk0OTQxNjcyMzU3OTM5MTc2NzgzMTk0MTIwNzI0NDQwNDkyMjA5MjA4Nzg5OTkwMDQ2ODMzNjYzODU4MjUxNTU2OTg3Njc3NjA1NTY3OTc2MTUwNjYyODM0MTcxMjM2MDY5MjgzODU2NTIwNjAwNjAxMDU4MjAxMzg2MjA3MjgyODU2Mzg0OTY5MTIxMjQ4MDU1NjY0Nzc1MDk1MzUzODMwNzQ1MzM1MTMxNTYxMjI1MzEyMzIwNjU4MjYzNzA3NzM4NjgwODgwODc0NDQ4MTUzODI3Mzg5Mzg4ODE1ODA4NjkwODI2NjQ2NTk3NDU5OTMwNTU1ODMxMjU0OTE3NjE0NjIxMzI1MzU3NjI1MjE3MzIyNDMzNjIwNzA2NTQ3MjM4OTI4MjczMDE4NTg5MjE0NDYyNDUyMzMxMTU4MzYzMTE5MzY1MDc0MjUwNTY5NDYxNjIzOTUyMjEwNTcyNTAxNjAxNDA1MzI5OTkwNzY1OTQzNzM2Njk4NTQwMDEwMTI1MDg4MDMwOTAyNTQ3NzYyMDQxMzc1NDAwNzA1MDczOTk0MDc5NjQ3MzY4OTc2MTM0NzQ3Njc4MDQ5ODQ1NzA1ODAyMTQzMTE1NTIyNDQzNDE5MDExMzAxNDQ3MzY1NjAyNDI5NjYwNzA5NTM3NDU4Mzg0OTk4MDg3OTUyODA2Nzc3MDcyODk0MTExMzk3MTk5MDg4MDg4Mjk2MzYwMzU4MjI2OTE0NTk4ODQ2MzY4Nzk0MTY=
# You win!
# Flag is: h0W_did_YoU_hAck_RSA
###################################


#####################################
### Перебор AES алгоритма
#####################################
### условие
#    We found the source code for this robot encryption service, except the key was redacted from it. The service is currently running at 23.21.15.166:4433
#    Title: Encryption Service (300)
#    Category: Password Guessing
### Мысли
"""
    The service basically implements an encryption Oracle, it reads data from the socket and returns the AES-CBC encrypted
    version of this data, concatenated with a secret string. The challenge is to find this secret string.

    Mulitple blocks can be submitted where the ciphertext of the previous block will be used as the IV for the next.
    The IV for the first block is randomly generated and sent to the client by the server. Data is encrypted in blocks of
    16 bytes (128 bits). The output provided is the encrypted version of <input> + <level_key> + <padding>.

    So how do we find the hidden challenge key… Let’s look at what happens if we supply input AAAA.
    In that case the input to AES looks as follows:

            block 1     |      block 2      |      block 3      |
            AAAA xxxx xxxx xxxx|xxxx xxxx xxxx xxxx|xppp pppp pppp pppp|

    In this example the x’s represent characters from the secret key and p are padding characters.
    In this case there is only one unknown byte in the third block which is the last character of the key.
    If we store the encrypted version of this block we can simply implement a linear search by first encrypting
    appp pppp pppp pppp, then bppp pppp pppp pppp, then cppp pppp pppp pppp, etc. Until we get an encrypted block
    which is equal to the block we are searching for.

    There is one slight complication here which are the IVs, which are meant to make sure that the same input doesn’t
    always encrypt to the same output. However the IV for the third block, which we are searching for, is simlpy the
    ciphertext of the previous block. So in practice the third block looks like this:

            (xppp pppp pppp pppp) xor (cipher_text_second_block)

    So if we submit (appp pppp pppp pppp) xor (cipher_text_second_block) xor (next_iv) where a is our guess for the last
    character of the key we receive the same output if a was guessed correctly.

    The nice thing about this approach, is that we can keep repeating it to reveal the next character of the key,
    for example to find the second character of the key we use input AAAAA which will yield the following encrypted block:

            block 1     |      block 2      |      block 3      |
            AAAA Axxx xxxx xxxx|xxxx xxxx xxxx xxxx|xxpp pppp pppp pppp|

    Since the last character of the key is known from the previous step we are again only left with a limited number
    of possibilities. This process can be repeated to reveal the entire key.

    We implemented the attack in python:
"""

def sample_Aes():
    import socket,struct,sys,string
    def make(data):
        return struct.pack('I',len(data)) + data

    def pad(data, blocksize=16):
        l = blocksize - (len(data) % blocksize)
        return data + chr(l) * l

    def get_enc(data):
        global s
        s.send(make(data))
        l = struct.unpack("I",s.recv(4))[0]
        data = s.recv(l)
        return data

    def string_xor(a,key):
        return ''.join(chr(ord(a[i]) ^ ord(key[i%len(key)])) for i in range(len(a)))

    def attack(key):
        global s
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect(('174.129.168.125', 4433))

        iv = s.recv(16)
        prefix = "A" * (4+len(key))
        enc = get_enc(prefix)
        third_block = enc[32:32+16]
        third_iv = enc[16:16+16]

        search = third_block
        print "Search block: %s" % search.encode('hex')

        iv = enc[-16:]

        for x in string.lowercase + '_':
            guess = string_xor(pad(x+key),third_iv)
            new = get_enc(string_xor(guess,iv))
            lb = new[:16]
            if lb == search:
                return x
            iv = new[-16:]


    key=''
    for x in range(29):
        new = attack(key)
        key = new + key
        print "Found: " + key

"""
    Running this program reveals the key:

            Search block: 107b4efae8d1befa1df39a0802fa6c1d
            Found: s
            Search block: afdfde9db5a44df21a84a089a9083f53
            Found: us
            Search block: eb632f01027fe10685716e9ecac582f5
            Found: ous
            ...
            Found: edictable_ivs_are_dangerous
            Search block: ad04e566628430aea3628fe85de85189
            Found: redictable_ivs_are_dangerous
            Search block: da429ea307dae8d1c2e58895545b004f
            Found: predictable_ivs_are_dangerous
"""

### Взлом RSA, основанный на малой экспоненте
### Plaid CTF 2012 – RSA
# Условие задачи http://dl.dropbox.com/u/17463542/zadacha.zip
# A very cool and surprisingly easy crypto challenge: all you have to do is break 4096-bit RSA!
# Of course, there are some special circumstances which make solving this possible at all.
# We have two files, one is the encrypted data (presumably, it is named enc.dat and looks like random data)
# and the other is a RSA public key in PEM format. Let’s list the details of this public key:

"""
user@box:~$ openssl rsa -noout -text -pubin -in rsa/id-rsa.pub
Modulus (4096 bit):
00:b0:a1:f3:90:ac:d3:d4:3b:47:d3:9f:13:26:62:
f6:9c:15:89:25:d9:28:71:e4:78:69:e2:84:1a:91:
7c:20:d5:10:24:31:b9:a9:78:14:58:d8:40:fd:29:
57:78:15:a4:16:12:d6:87:a3:48:7d:26:fb:ae:25:
6f:15:d4:74:0c:34:59:1b:64:6a:bc:cc:b1:a2:7a:
cd:e2:99:b3:e7:16:00:85:7b:45:5c:28:36:60:e0:
45:5c:68:ff:45:c0:64:4c:fe:c2:11:d7:f5:1a:16:
c8:2e:91:d7:86:d9:2c:79:9f:b3:cb:48:f9:2d:e3:
42:ba:70:dd:82:13:05:6b:31:4a:8d:51:da:94:93:
cf:1b:86:ec:15:fd:f0:3e:04:6e:76:d3:f1:a1:ad:
0a:ab:b6:84:ce:5d:15:7e:39:98:28:a6:3a:5a:f5:
92:02:28:bb:5e:a1:e6:6b:8f:ea:a3:cc:bb:af:f5:
55:e3:46:79:77:30:dd:fc:1c:4c:f4:a9:dd:40:65:
88:62:93:48:c4:c2:92:65:df:9e:2c:3d:02:55:8b:
e5:e3:5c:b2:77:f4:e7:ac:7b:51:58:ef:39:03:a3:
96:48:63:71:02:9e:54:a3:45:29:2a:ba:47:49:9f:
1c:26:7e:68:0a:e7:38:19:5f:d5:af:2a:80:75:93:
98:90:f5:d6:9e:6b:3e:94:e3:e5:60:86:1a:a6:c6:
c6:9d:a8:24:05:db:a2:18:2e:66:ec:ff:6a:8a:9c:
df:5a:d5:22:6f:07:3e:7d:52:5e:05:0f:dd:77:e0:
bb:18:91:a4:9e:fe:c2:d3:67:a6:93:d2:a6:79:9d:
0d:46:67:95:3d:4f:3d:de:c1:6a:c1:5b:b4:cf:60:
25:ea:58:ec:b6:df:a5:72:31:6d:a0:8d:31:06:07:
39:73:32:2a:e7:59:74:46:f2:fd:30:43:df:6e:1d:
60:4c:6a:1f:0e:59:47:3d:9b:c1:82:d4:ec:6f:c4:
58:8f:1c:6b:2a:a4:76:87:6a:84:b2:d4:e0:d4:59:
10:39:91:18:d7:e1:e2:0d:cc:27:70:3f:2b:d3:e9:
af:72:2f:37:a7:67:3b:15:d6:74:92:28:62:c8:4d:
00:fc:2f:c7:dd:dd:c9:15:c4:69:3f:cb:0b:17:89:
e9:dc:bd:72:ac:04:65:9e:7c:18:dc:f3:62:54:76:
00:40:40:2b:fc:ef:11:b8:a3:ef:9c:8b:dd:ba:aa:
8d:14:c6:e8:f5:18:a7:0b:03:6d:20:6b:80:9c:d9:
b3:b5:1a:1e:c0:13:2d:ac:e9:6d:ca:94:51:f3:4c:
38:ab:84:ed:47:5e:7d:94:fb:e9:ff:c0:07:f2:d1:
48:60:bd
Exponent: 3 (0x3)
"""

# This is already a bit odd. Almost all RSA keys have a much higher exponent these days (usually 0×10001)
# because there are some attacks possible with low exponents. Googling for specific details on this half-remembered
# fact mostly yields attacks which are only possible when you have lots of messages, but we only have one of course.
# But maybe it is so simple that it doesn’t really get much mention on the internet these days?

# One thing which is quite important when using RSA is to add proper cryptographic padding to your message
# (and to check the padding when decrypting, but we don’t have anything that decrypts data for us here).
# Remember, RSA encryption without padding is just raising the message to the power of your exponent (3)
# and then taking the remainder after division by the modulus.

# The remainder (or modulus) operation is very important here, if it wasn’t there we could simply take the cubic
# root of the ‘encrypted’ value to recover the plaintext.

# However, if someone were to encrypt a relatively short, unpadded ascii message with such a low exponent
# and such a high modulus, the modulus operation actually doesn’t make our life all that much harder.
# To see why let’s take a look at the minimum and maximum values for the ‘encrypted’ value before the modulus operation.

def sample_RSA_lowexpo():
    import gmpy

    # Pubkey
    n = 0xb0a1f390acd3d43b47d39f132662f69c158925d92871e47869e2841a917c20d5102431b9a9781458d840fd29577815a41612d687a3487d26fbae256f15d4740c34591b646abcccb1a27acde299b3e71600857b455c283660e0455c68ff45c0644cfec211d7f51a16c82e91d786d92c799fb3cb48f92de342ba70dd8213056b314a8d51da9493cf1b86ec15fdf03e046e76d3f1a1ad0aabb684ce5d157e399828a63a5af5920228bb5ea1e66b8feaa3ccbbaff555e346797730ddfc1c4cf4a9dd406588629348c4c29265df9e2c3d02558be5e35cb277f4e7ac7b5158ef3903a396486371029e54a345292aba47499f1c267e680ae738195fd5af2a8075939890f5d69e6b3e94e3e560861aa6c6c69da82405dba2182e66ecff6a8a9cdf5ad5226f073e7d525e050fdd77e0bb1891a49efec2d367a693d2a6799d0d4667953d4f3ddec16ac15bb4cf6025ea58ecb6dfa572316da08d3106073973322ae7597446f2fd3043df6e1d604c6a1f0e59473d9bc182d4ec6fc4588f1c6b2aa476876a84b2d4e0d45910399118d7e1e20dcc27703f2bd3e9af722f37a7673b15d674922862c84d00fc2fc7ddddc915c4693fcb0b1789e9dcbd72ac04659e7c18dcf36254760040402bfcef11b8a3ef9c8bddbaaa8d14c6e8f518a70b036d206b809cd9b3b51a1ec0132dace96dca9451f34c38ab84ed475e7d94fbe9ffc007f2d14860bdL
    e = 0x3
    # Message
    msg_str = '\x4a\x69\x06\x21\xbd\x15\x0c\xf6\x93\xed\x8c\x85\x70\x8b\x6d\x0f\xa2\xcc\x85\x0b\x48\x73\x64\x43\x08\x23\x8f\x38\x03\x1a\x93\x31\x02\xf6\x66\xb8\x92\x68\x99\x60\x6e\x49\x1f\x36\x0a\x24\xd2\x6b\x9e\x91\x5e\xd6\xa1\x28\x49\x2b\x14\x47\x99\xe9\xee\xd2\x50\x05\x0a\x2d\xef\xa2\xac\x53\x52\xb0\x49\x2c\x98\x83\x28\xb0\x74\x36\xb8\x26\xa5\x00\xf9\x19\x35\xac\x58\x1c\x0c\x60\x66\xa7\xa9\x49\x46\xf2\x1e\x29\x0b\x1b\x2f\xbd\xf6\x73\xad\xb0\x5c\x04\x45\x90\x5b\xdd\x88\x01\xc9\x3c\xfb\x4c\xe7\x43\xcd\x62\xbf\x79\xe9\x7f\x95\x9c\xb9\x44\x9f\xc3\x7d\xbf\x5c\xd3\x15\x56\x5b\xb0\xc4\x33\x69\xe6\x47\x3b\xc9\x7d\x2d\xb5\xcc\x2c\x01\xde\x75\x0b\x99\x59\xb8\xde\x3d\x53\x95\xf1\x1f\xa8\xbb\xe8\x8b\x8d\xfe\x52\x1d\x78\x2d\xfd\x41\x66\x4c\x08\x2a\x80\x6b\xfe\x7f\x30\x0b\x56\x33\x27\x4f\xdd\x5f\x22\x93\xe0\xd0\xc2\x1e\xc6\xb1\xd2\xc9\x3f\xc0\x4d\x22\xf1\xaa\x1c\x9e\x0a\xad\xfa\x28\x54\xcf\x32\x59\x51\xfc\xfe\x84\xec\x4e\xd2\xa5\xc9\x10\xed\xb3\x2b\xba\x9f\x25\xab\xfe\x53\x42\x03\xef\x3e\xbb\x1d\x36\xfa\x3b\x12\x55\xb8\xa3\x49\xc4\xa7\x70\x66\xd1\xc3\xf2\x65\x90\x0d\x11\xca\x1b\x6a\x80\x66\xff\x01\xe4\x98\x05\x8d\x55\x7a\x15\x05\x48\x82\xdd\x13\x6c\x06\x4e\x9c\xe2\x8e\x2d\x44\x05\x35\x76\x73\xac\x23\xf6\x31\x06\x43\xdb\x0b\x93\xa3\x99\x6e\xe6\x5d\x15\xe0\x86\xea\x68\x77\x18\x01\x6b\x18\x41\x08\xa7\x2f\xc9\x79\xfa\x72\xb4\x91\x3a\xa7\x79\x28\x96\xf5\x1c\x68\xfc\x97\x91\x77\x35\xd7\xe2\x86\x4b\xd3\x84\xcf\x9b\x77\xaf\xd2\xc6\xbd\xfc\xdd\x32\x54\x13\x9a\x69\xb6\x45\xb1\x52\x42\x4b\xa9\x02\x79\xe2\x75\x56\x3a\xf5\x2f\xec\x48\x7e\x68\xd0\xba\x3c\x42\x2d\x00\x07\xe2\x6f\xfc\x9a\x03\xce\x98\x90\xdd\x38\x15\x3a\x36\x46\xd4\x9d\xc0\x71\xe1\xfd\x7a\x3c\x42\x1a\xd2\x1b\x62\xeb\x63\xce\x40\x88\x7d\xd6\x0b\x60\x13\x4a\x1e\xf0\x6c\x60\x9e\xf4\x6d\xb6\xd9\x92\x9e\xab\xfb\x15\x93\x2d\x5d\x7a\xc7\x0b\xec\xf1\xb4\xca\xf8\x55\x14\xd3\x15\x1f\x30\xce\x69\x65\xf9\xd1\x67\x21\xe8\x65\xb7\xd3\x01\x48\xf6\xb8\x46\xe5\x03\x15\xb7\x0e\x1e\xfd\x7a\xd8\xe4\xff\x9f\x1d\x84\xfb\xa4\x10\x81\x16\x71\xe5\x6d\xe2\x46\x96\x55\xce\xd0\x14\xd0\x09\xe1\x27\x97\x38\x21\xf3\x23'
    msg_num = int(msg_str.encode('hex'), 16)

    ubound = pow(int('7D' * 172,16), e)
    lbound = pow(int('20' * 172,16), e)
    # We were working on this after the hint that the plaintext was 172 characters, so we can use that here.
    # Otherwise we’d just have to try all the different lengths, starting from low values and working our way up.
    # This first calculates the result of raising the ‘smallest’ possible message (consisting entirely of spaces)
    # to the third power, and then does the same for the “largest” possible message in the ascii range.
    # Now remember that ciphertext is the remainder of the real message raised to the third power modulo n
    # (n being the modulus part of the rsa public key).

    #ciphertext = pow(plaintext, 3) % modulus
    # 'ciphertext' is the remainder, so all we need to know to take the cubic root is the quotient 'q'
    # ciphertext + modulus * q = pow(plaintext, 3)
    max_q = ubound / n
    min_q = lbound / n
    print max_q - min_q # This gives the number 732851516. That’s pretty big, but it’s certainly doable on a fast system with a good big-number library
    gs = gmpy.mpz(msg_num)
    gm = gmpy.mpz(n)
    g3 = gmpy.mpz(3)
    mask = gmpy.mpz(0x8080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808000)

    for i in xrange(min_q, max_q):
        gs += gm
        root,exact = gs.root(g3)
        if (root & mask).bit_length() < 8:
            print ('0%x' % root).decode('hex') # Turns out our assumption that spaces would be the lowest characters in the string was actually incorrect: this message starts with a linefeed!
            # Adding a 0 to the start of the hex string allows us to decode it as ascii and see that this is actually the correct answer, and we just got lucky:

### Тоже самое, только от команды leetmore
# Немного элегантнее, но на порядок непонятнее
from libnum import *
def sample_RSA_lowexpo2():
    import gmpy
    N = long('00b0a1f390acd3d43b47d39f132662f69c158925d92871e47869e2841a917c20d5102431b9a9781458d840fd29577815a41612d687a3487d26fbae256f15d4740c34591b646abcccb1a27acde299b3e71600857b455c283660e0455c68ff45c0644cfec211d7f51a16c82e91d786d92c799fb3cb48f92de342ba70dd8213056b314a8d51da9493cf1b86ec15fdf03e046e76d3f1a1ad0aabb684ce5d157e399828a63a5af5920228bb5ea1e66b8feaa3ccbbaff555e346797730ddfc1c4cf4a9dd406588629348c4c29265df9e2c3d02558be5e35cb277f4e7ac7b5158ef3903a396486371029e54a345292aba47499f1c267e680ae738195fd5af2a8075939890f5d69e6b3e94e3e560861aa6c6c69da82405dba2182e66ecff6a8a9cdf5ad5226f073e7d525e050fdd77e0bb1891a49efec2d367a693d2a6799d0d4667953d4f3ddec16ac15bb4cf6025ea58ecb6dfa572316da08d3106073973322ae7597446f2fd3043df6e1d604c6a1f0e59473d9bc182d4ec6fc4588f1c6b2aa476876a84b2d4e0d45910399118d7e1e20dcc27703f2bd3e9af722f37a7673b15d674922862c84d00fc2fc7ddddc915c4693fcb0b1789e9dcbd72ac04659e7c18dcf36254760040402bfcef11b8a3ef9c8bddbaaa8d14c6e8f518a70b036d206b809cd9b3b51a1ec0132dace96dca9451f34c38ab84ed475e7d94fbe9ffc007f2d14860bd', 16)
    orig = s2n(open("enc.dat").read().rstrip())

    c = orig
    while True:
        m = gmpy.root(c, 3)[0]
        if pow(m, 3, N) == orig:
            print "pwned", n2s(m)
            break
        c += N

sample_RSA_lowexpo()
sample_RSA_lowexpo2()
